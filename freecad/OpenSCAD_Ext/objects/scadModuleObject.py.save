from freecad.OpenSCAD_Ext.logger.Workbench_logger import write_log
from freecad.OpenSCAD_Ext.commands.baseSCAD import BaseParams
from freecad.OpenSCAD_Ext.objects.SCADObject import SCADfileBase, ViewSCADProvider
#
# Called with 
# Wrap in SCADModuleObject
# SCADModuleObject(obj, self.meta, self.selected_module_meta, args=args_values)  
#
# self.meta : SCADMeta
# self.selected_module_meta : SCADModule: 
#
# --- Data Classes ---
#class SCADArgument:
#    def __init__(self, name, default=None, description=None):
#        self.name = name
#        self.default = default
#        self.description = description
#
#class SCADModule:
#    def __init__(self, name):
#        self.name = name
#        self.description = ""
#        self.usage = []
#        self.includes = []
#        self.arguments = []
#
#class SCADMeta:
#    def __init__(self, sourceFile):
#        self.sourceFile = sourceFile
#        self.baseName = os.path.basename(sourceFile)
#        self.includes = []          # Includes in the file
#        self.comment_includes = []  # Includes found in file header comments
#        self.modules = []           # List of SCADModule objects
  
import os

class SCADModuleObject(SCADfileBase):
    def __init__(self, obj, name, sourceFile, meta, module, args):
        # SCADfileBase(self, obj, scadName, sourceFile, mode='Mesh', fnmax=16, timeout=30, keep=False):
        super().__init__(
            obj,
            self.clean_module_name(name),
            sourceFile
        )
        self.Object = obj
        #self.sourceFile = meta.sourceFile
        #self.scadName = meta.baseName
        self.meta = meta
        self.module = module
        self.args = args
        obj.Proxy = self

        write_log("INFO",f"library scad file {meta.sourceFile}")
        write_log("INFO",f"includes {meta.includes}")
        write_log("INFO",f"modules {module.name}")
        write_log("INFO",f"args {args}")
        
        self._init_properties(obj, meta, module)
        # defaults set when creating properties
        # self._set_defaults(obj, module)
        # Need to do properties before build_scad_source
        # refresh_scad_source ??
        self._build_scad_source(obj) # obj ?
        self.add_args_as_properties(obj)
        self.renderFunction(obj)
    
    def _init_properties(self, obj, meta, module):
        # --- Parameters group ---
        obj.addProperty(
            "App::PropertyString",
            "ModuleName",
            "Parameters",
            "OpenSCAD module name"
        ).ModuleName = self.module.name

        obj.addProperty(
            "App::PropertyString",
            "Description",
            "Parameters",
            "Module description"
        ).Description = module.description

        obj.setEditorMode("Description", 1)
        '''
        obj.addProperty(
            "App::PropertyString",
            "Usage",
            "Parameters",
            "Usage examples"
        ).Usage = "\n".join(module.usage, [])

        obj.setEditorMode("Usage", 1)

        # Collect argument documentation
        arg_info = []
        for arg in module.get("arguments", []):
            line = arg["name"]
            if arg.get("description"):
                line += " â€“ " + arg["description"]
            arg_info.append(line)

        obj.addProperty(
            "App::PropertyString",
            "ArgumentsInfo",
            "Parameters",
            "Argument documentation"
        ).ArgumentsInfo = "\n".join(arg_info)

        obj.setEditorMode("ArgumentsInfo", 1)
        '''

    def add_args_as_properties(self, obj):
        # --- Add to SCAD group ---
        #obj.addProperty(
        #    "App::PropertyStringList",
        #    "Includes",
        #    "SCAD",
        #    "Required include files"
        #).Includes = meta.get("includes", [])

        #obj.addProperty(
        #    "App::PropertyString",
        #    "Source",
        #    "SCAD",
        #    "Generated OpenSCAD source"
        #)

        #obj.setEditorMode("Source", 1)

        # --- Add module parameters dynamically ---
        for arg in self.module.arguments:
            name = arg.name
            default = arg.default
            description = arg.description

            prop = obj.addProperty(

                "App::PropertyString",
                name,
                "Module Parameters",
                description

            )
        
            if default is not None:
                setattr(obj, name, str(default))


    #def _set_defaults(self, obj, module):
    #    obj.ModuleName = module["name"]

    def execute(self, obj):
        # src = self._build_scad_source(obj)
        # obj.Source = src

        # Hook to existing OpenSCAD execution
        # run_openscad(obj, src)
        pass

    def clean_module_name(self, name: str) -> str:
        if name.endswith("()"):
            return name[:-2]
        return name

    #class SCADArgument:
    #    def __init__(self, name, default=None, description=None):
    #        self.name = name
    #        self.default = default
    #        self.description = description


    from freecad.OpenSCAD_Ext.logger.Workbench_logger import write_log

def scad_value(val):
    """
    Convert a FreeCAD property value to a valid OpenSCAD value.
    Booleans -> true/false
    Uppercase symbols -> leave as-is
    Strings -> quoted
    Numbers -> as-is
    """
    if isinstance(val, bool):
        return "true" if val else "false"
    if isinstance(val, str):
        if val.isupper():  # treat as OpenSCAD symbol
            return val
        return f'"{val}"'
    return val

    from freecad.OpenSCAD_Ext.logger.Workbench_logger import write_log        

def build_arg_assignments(obj, module):
    """
    Build a comma-separated string of argument assignments for a SCAD module.

    obj    : FreeCAD object with PropertiesList
    module : SCADModule meta object (has module.arguments list of SCADArgument)
    """
    assignments = []

    for arg in getattr(module, "arguments", []):
        name = arg.name

        # Only include if the FreeCAD object actually has this property
        if name not in obj.PropertiesList:
            continue

        val = getattr(obj, name)

        # Skip empty values
        if val in ("", None):
            continue

        assignments.append(f"{name}={scad_value(val)}")

    result = ", ".join(assignments)
    write_log("Info", f"Generated SCAD arguments: {result}")
    return result

        
def _build_scad_source(obj):

        # Log the current source file
        write_log("Source File", obj.sourceFile)

        # Get the SCAD source directory from BaseParams (static method)
        scad_dir = BaseParams.getScadSourcePath()

        # Build the full SCAD file path
        obj.Proxy.sourceFile = os.path.join(scad_dir, obj.Name + ".scad")

        # Make sure the directory exists
        os.makedirs(scad_dir, exist_ok=True)

def write_scad_file(obj, module, meta):
        """
        Write a SCAD file from a FreeCAD object and SCAD module meta.

        Writes:
            1. Comment includes
            2. Regular includes
            3. Module declaration (module name(args);)
            4. Module call with current obj parameter values
        """
        module_name = module.name.strip("()")  # Clean module name
        args_names = [arg.name for arg in module.arguments]  # Names only
        args_declaration = ", ".join(args_names)             # arg1, arg2, ...
        args_values = build_arg_assignments(obj, module)     # arg1=val1, arg2=val2, ...

        try:
            with open(obj.Proxy.sourceFile, "w", encoding="utf-8") as fp:
                write_log("Info", f"Writing SCAD file: {obj.Proxy.sourceFile}")

                # Comment includes first
                for inc in meta.comment_includes:
                    print(f"include <{inc}>;", file=fp)

                # Then normal includes
                for inc in meta.includes:
                    print(f"include <{inc}>;", file=fp)

                print("", file=fp)  # Blank line for readability

                # Module declaration (no values)
                print(f"module {module_name}({args_declaration});", file=fp)

                # Module call with current object argument values
                print(f"{module_name}({args_values});", file=fp)

                write_log("Info", f"Module '{module_name}' written with args: {args_values}")

        except Exception as e:
            write_log("Error", f"Failed to write SCAD file {obj.Proxy.sourceFile}: {e}")

def _module_source_from_library(lines):
        # maybe find and save original source as property
        # Need to deal with case if library changes
        # SCADModuleObject maybe no edit
        # So maybe SCADfileBase, SCADObject and SCADModuleObject
        #lines.append("#ToDo Add from library defintion")
        # defintion is in library so should not add
        pass

def _add_argument_property(obj, arg):
    name = arg.name
    default = arg.default
    desc = arg.description
    subsection = "SCAD Parameters"

    # Boolean
    if default in ("true", "false"):
        prop = obj.addProperty(
            "App::PropertyBool",
            name,
            subsection,
            desc
        )
        setattr(obj, name, default == "true")
        return

    # Integer
    try:
        if default is not None and "." not in str(default):
            ival = int(default)
            prop = obj.addProperty(
                "App::PropertyInteger",
                name,
                subsection,
                desc
            )
            setattr(obj, name, ival)
            return
    except Exception:
        pass

    # Float
    try:
        fval = float(default)
        prop = obj.addProperty(
            "App::PropertyFloat",
            name,
            subsection,
            desc
        )
        setattr(obj, name, fval)
        return
    except Exception:
        pass

    # String fallback
    prop = obj.addProperty(
        "App::PropertyString",
        name,
        subsection,
        desc
    )
    if default:
        setattr(obj, name, str(default).strip('"'))

